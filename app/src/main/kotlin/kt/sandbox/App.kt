/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package kt.sandbox

import com.couchbase.client.kotlin.Cluster
import com.couchbase.client.kotlin.CommonOptions
import com.couchbase.client.kotlin.codec.*
import com.couchbase.client.kotlin.kv.*
import com.couchbase.client.kotlin.query.QueryDiagnostics
import com.couchbase.client.kotlin.query.QueryParameters
import com.couchbase.client.kotlin.query.QueryParameters.Named
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.toList
import java.nio.charset.StandardCharsets.UTF_8
import java.time.Duration
import java.time.Instant
import java.util.*
import kotlin.system.measureTimeMillis

internal class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}


public fun main() {
    System.setProperty(DEBUG_PROPERTY_NAME, DEBUG_PROPERTY_VALUE_ON)





    println(Long.MAX_VALUE)
    println(Instant.ofEpochMilli(Long.MAX_VALUE))


//    val mapper = jsonMapper { addModule(Jdk8Module()) }
//
//    println(mapper.writeValueAsString(NullNode.instance))
//    println(mapper.readTree("null").javaClass)
}


public data class Dingus(public val name: String)

internal fun zot(foo: String = UUID.randomUUID().toString().also { println("calculated!") }): String = foo


internal fun query() = runBlocking {
    val cluster = Cluster.connect("localhost", "Administrator", "password")
        .waitUntilReady(Duration.ofSeconds(10))

    println("cluster ready!")

    val other = cluster.bucket("other").defaultCollection()
    val content: String? = null;
    other.upsert("null", Content.json("null"))



    val s: String? = other.get("null").contentAs<String?>()
    println(s == null)

    println(other.get("null").content.toStringUtf8())

//    return@runBlocking

    val queryResult2 = cluster.query(
        "select meta().id, * from default as doc where click = \$val",
        //parameters = Positional("to edit"),
        parameters = Named("val" to "to edit"),
        readonly = true,
        diagnostics = QueryDiagnostics(metrics = true),
    )

    println("unified flooooow!")

    for (i in 1..100) {

        var results = listOf<GetResult>()

        val deferrals = ArrayList<Deferred<GetResult>>()


        val elapsed = measureTimeMillis {
            val ids = listOf("foo", "huh?", "whatzit", "whosit", "zot")
            results = ids.asFlow()
                .map { async { other.get(it) } }
                .toList().awaitAll();


//            /results.addAll(deferrals.awaitAll())
        }

        println("results!!!! in ${elapsed}ms  " + results.map { it.content.toStringUtf8() });
    }


    val foo: Deferred<MutationResult> = async { other.upsert("huh?", "who?") }
    foo.await()

    val x: String? = null;
    other.upsert("foo", x)

//    val elaspedMillis = measureTimeMillis {


//        queryResult2.rows()
//            .flatMapMerge(1000) {
//                println("${Thread.currentThread()} got result item ${it}")
//
//                if (it is QueryRow) {
//                    println(it.content.toStringUtf8())
//                }
//
//                when (it) {
//                    is QueryRow -> flow {
//                        println("${Thread.currentThread()} upserting")
//                        delay(1000)
//
//                        val row = it.contentAs<ObjectNode>()
//                        val content = row.path("doc") as ObjectNode
//                        val id = row.path("id").textValue()
//
//                        emit(other.upsert(id, content))
//                    }
//
//                    is QueryError -> TODO()
//                    is QueryMetaData -> flow {
//                        println("got meta, not emitting: ${it}")
//                    }
//                }
//            }
//            .collect {
//                println("${Thread.currentThread()} ${it}")
//            }
//    }
//            println(Thread.currentThread())
//            when (it) {
//                is QueryRow -> {
//                    println("got row: ${it.contentAs<Map<String, Any?>>()}")
//                    other.upsert("foo", it.content, transcoder = RawJsonTranscoder)
//                }
//                is QueryError -> TODO()
//                is QueryMeta -> println("got meta: ${it}")
//            }
//        }


//    println("done with unified flooooow! in ${elaspedMillis}ms")

//
//    try {
//        val queryResult = cluster.query(
//            "select * from default where click = \$val",
//            //parameters = Positional("to edit"),
//            parameters = Named("val" to "to edit"),
//            readonly = true,
//        )
//        println(queryResult.metaData().status)
//
//        val flow = queryResult.rowsAs<Map<String, Any?>>()
//        flow.collect { println(it!!["default"]) }
//
//        println("collecting again!")
//        flow.collect { println(it!!["default"]) }
//
//        println("done collecting again!")
//
//
////        val trailer = queryResult.response.trailer().awaitSingle()
////        println("trailer: ${trailer}")
//
//    } catch (t: Throwable) {
//        println(" collecting failed: ${t}")
//        t.printStackTrace()
//    }
//
//
////    val flow = queryResult.response.rows().asFlow()
//
//    println(Thread.currentThread())

//    try {
//        flow
//            .map { qcr -> qcr.data().toStringUtf8() }
//            .collect { println("${Thread.currentThread()} ${it}") }
//
//    } catch (e: Exception) {
//        println("The flow has thrown an exception: $e")
//    }


}


internal fun foo() = runBlocking {

//    val publisher = Flux.just("a", "b", "c")
//    val sharedFlow = MutableSharedFlow<String?>(replay = 1000)
//    val flow = publisher.asFlow()
//
//    flow.catch { }
//
//
//    println("emitting")
//    sharedFlow.emitAll(flow.onCompletion { sharedFlow.emit(null) })
//
//    println("collecting")
//    sharedFlow
//        .takeWhile { it != null }
//        .collect { println(it) }
//
//    println("done collecting")


    val cluster = Cluster.connect("localhost", "Administrator", "password")
        .waitUntilReady(Duration.ofSeconds(10))

    println("cluster ready!")
    // cluster.query("SELECT * from default")

    val queryResult = cluster.query(
        "select * from default",
        //parameters = QueryParameters.Named("doo" to "bar")

//        parameters = Named(
//            "foo" to 123,
//            "dingus" to Dingus("Alphonse"),
//            "bar" to mapOf(
//                "123" to "xyz"),
//        ),
//        raw = mapOf("xxxx" to null),
//        diagnostics = QueryDiagnostics(metrics = true, profile = QueryProfile.TIMINGS),
        readonly = true,

//        consistency = consistentWith(listOf(MutationToken(1,2,3,"foo"))),
//        //clientContextId = null,
//        tuning = QueryTuning(maxParallelism = 2, scanCap = 123),
    )


    //   val cluster = Cluster.connect("localhost", "Administrator", "password")
//    println(
//        collection.get(
//            "foo", GetOptions(
//                timeout = null
//            )
//        ).content.toString(UTF_8)
//    )
    val collection = cluster.bucket("default")
        .waitUntilReady(Duration.ofSeconds(10), setOf()).also { println("bucket ready!") }
        .defaultCollection()

    println(collection)

//    println("loading foo 3 times")

    // val serializer = JacksonJsonSerializer(mapper)
//    val serializer: JsonSerializer = KotlinxSerializer()
    val serializer: JsonSerializer = MoshiJsonSerializer(Moshi.Builder()
        .addLast(KotlinJsonAdapterFactory())
        .build())

    val transcoder = JsonTranscoder(serializer)

    println(serializer.deserialize("null".toByteArray(UTF_8), typeRef<String>()))

    val x = serializer.deserialize("[\"nool\"]".toByteArray(UTF_8), typeRef<List<String>>())

    println(x)
    println(x?.javaClass)

    val t = typeRef<List<String>>()

    println(t)
    val obj = Project("Hank", "English")

    collection.upsert("bar", listOf(obj, obj),
        expiry = Expiry.none(),
        durability = Durability.clientVerified(ReplicateTo.ONE, PersistTo.ACTIVE)
    )

    //collection.upsert("bar", listOf(obj, obj), expiry = Expiry.relative(Duration.ofSeconds(10)))

    collection.upsert("raw", Content.binary("boogers".toByteArray()))
    println("got raw: " + collection.get("raw").content.toStringUtf8())

    val out = collection.get("bar").contentAs<List<Project>>(transcoder)
    println("*** $out")

    collection.get("bar").contentAs<List<Project>>(transcoder)


    collection.upsert("foo", options = CommonOptions(),
        content = null as String?,
        durability = Durability.persistToMajority()
      //  expiry = relative(Duration.ofSeconds(30))
    )

   // cluster.query("select * from default", parameters = QueryParameters.named())

    collection.upsert("foo", options = CommonOptions(), content = null as String?,
        expiry = Expiry.none()
    )


    val proj = out.first()
    println(proj.name)


    collection.upsert("zoinks2", mapOf("foo" to mapOf("x" to "y")))

    println("class: ${out.first().javaClass}")


//    collection.get("foo")
//    collection.get("foo")
//    println("done loading foo 3 times")
//

    println("$$$" + collection.upsert("magicWord", listOf(Project("xyzzy", "ick", listOf("1")))))

    val w = runCatching { collection.get("magicWord") }
        .mapCatching { it.contentAs<List<Project>>(JsonTranscoder(KotlinxJsonSerializer())) }
        .getOrThrow()

    println("$$$" + w)


//        "xyzzy".toByteArray(UTF_8),
//        "\"xyzzy\"".toByteArray(UTF_8),


    //expiry = Expiry.Relative(Duration.ofSeconds(3)),
    //durability = Durability.polling(PersistTo.TWO, ReplicateTo.NONE)
//        durability = Durability.polling(PersistTo.NONE, ReplicateTo.NONE),
//
//        expiry = Exp
    //  expiry = Expiry.absolute(Instant.now()),
//        durability = Durability.persistToMajority(),
//        options = RequestOptions()
//    ))


//    println("result! " +
//            collection.get(
//                "foo",
//                withExpiry = true,
//                projections = listOf("__crypt_one.alg")
//            ).content.toString(UTF_8)
////    ).content
//    )

//
//    collection.get("foo") { timeout = Duration.ofMillis(0) }
//
//    println(
//        collection.get("foo").content.toString(UTF_8)
//    )


}


internal fun dumpFlags(flags: Int) {
// 50333696
    // CodecFlags.extractCommonFlags()


}

internal fun ByteArray.toStringUtf8() = toString(UTF_8)
